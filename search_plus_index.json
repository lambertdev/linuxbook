{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 无论你是内核开发人员，还是Python程序员，甚至是Web前端工程师，在日常工作中都离不开操作系统。Linux作为应用最为广泛的操作系统（没错，不是之一），其开源的内核代码以及良好的社区氛围，使其成为广大计算机相关专业学生和IT从业人员学习操作系统的不二选择。 本系列文档是作者工作以来抽空学习Linux操作系统内核实现的总结，多数为博客文章重新汇编整理。整理过程中会重新审查技术和表述的准确性，避免产生误导。 本系列文档会按照Linux内核不同子系统进行分章节介绍。主要涵盖的子系统有： 内核编译及加载 内存管理 进程管理 终端 设备驱动模型 PCI子系统 SDIO子系统 待补充..... 目标读者 文档的目标读者为： 驱动开发人员 对操作系统及内核技术感兴趣的专业及非专业人员 想要了解Linux内核，希望可以为开源社区做贡献的学生 阅读本系列文档前，你需要： 可以熟练使用C语言编程 可以使用GNU Make命令和GCC进行程序编译 熟悉Linux命令行环境 参考资料 Linux源码, https://elixir.bootlin.com/linux/latest/source Linux内核文档, https://www.kernel.org/doc/html/latest/ Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"3-Memory Management/0-Introduction.html":{"url":"3-Memory Management/0-Introduction.html","title":"Introduction","keywords":"","body":"内存系统是操作系统最重要、最基础、最复杂的子系统之一，内存管理穿插着内核的方方面面。本系列文章希望对Linux内核内存管理的知识做一个梳理，力求清晰准确。 通过阅读本系列，您将了解到： 内核在系统内存管理中的职责。 内核对物理内存的管理模式。 地址空间的划分。 内存的分配释放管理。 进程虚拟内存管理 现有的一些内核内存检测工具及其工作原理。 本文旨在帮您了解内核中内存管理的工作原理，并不会涵盖如下内容： 内存的分类及工作原理。 内存的硬件电路设计。 本文针对的对象为： Linux应用或内核驱动开发者。 想要从具体实现来了解操作系统内存管理原理的学生。 想要了解Linux内核内存管理相关知识的计算机爱好者。 了解本文所介绍知识前，您需要对如下知识有一定掌握程度： C语言 计算机组成原理 操作系统原理 为了阐述方便，本系列会基于Intel 64位平台做讨论。其中所涉内核代码主要位于如下目录： mm arch/x86 您可以到kernel.org下载最新内核源码辅助阅读。也可到Bootlin在线阅读内核源码。 Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"3-Memory Management/1-Overview.html":{"url":"3-Memory Management/1-Overview.html","title":"Overview","keywords":"","body":"内存管理子系统职责 为了支持系统中各式各样的应用和驱动，使之能够高效地运行，内核内存管理子系统要完成以下职责： 内核初始化过程中，物理内存使用的规划。其中包括： 内核CMDLine、内核映像等的摆放 内核解压位置的选择 内核初始化完成后，回收不再使用的代码或数据段 系统运行中内存分配释放管理。分配器需要考虑： 分配效率 碎片避免及管理 物理内存区域的划分和管理。包括： 物理内存的划分：采用不同大小的单元对物理内存进行管理。 非一致性内存访问（NUMA）：多处理器系统中可能有多个内存节点。每个处理器和每个内存节点距离并不相同，因此访问不同的内存节点效率也不尽相同。NUMA就是提供内存访问管理机制，使得通过用户配置结合内核自身策略，提升应用或内核访问内存的效率。 内存的热拔插管理。 进程虚拟地址空间的管理 在Linux系统中，每个进程都可以拥有0地址开始的2^n(n为主机地址线位数)的线性地址空间。操作系统通过为每个进程建立独一无二的页表，结合对内存的换入换出，使得进程看到的可用内存大小，远大于系统实际内存大小。同时也有效隔离了不同进程的地址空间。 与此同时，因为内核态程序可能在任何进程的上下文执行，内核需要保证所有内核态程序所访问资源的一致性，又必须将每个进程的固定地址范围做同样的映射并指向内核。 内存换入、换出及回收 内核会根据一定的策略结合内存使用状况，将暂时使用不到的内存资料换入到磁盘。而当该内存被再次需要时，将其换回。 同时内核会监控系统的内存负载状况，在合适的时机回收内存。 内存使用的调试和检测 内核提供了一系列的工具，可以自动系统运行中对内存的错误使用进行检测。当然这些检测手段会带来一定系统开销，所以为了使用他们，可能需要专门地开启。 内核内存管理架构 如上Linux内核内存管理的架构图： 用户空间态APP通过libc（glibc、uClibc、llvm-libc）提供的C语言库函数，进行内存申请、释放等操作。 void *malloc(size_t size); void *calloc (size_t n, size_t len); void free(void *ptr); int munmap (void *start, size_t len); libc通过系统调用，向内核内存管理子系统发送内存管理请求 内核内存管理子系统包含： Memblock分配器，即原Boot Allocator Buddy Allocator(伙伴系统) SLAB分配器 页表管理模块 内存映射管理模块 I/O设备地址映射管理模块 内存划分方式 Node 1 Node 2 Node 3 +----------+ +----------+ +----------+ | | | | | | |Zone_High | | | | | | | | | | | +----------+ | | | | | | | | | | | | | | | | |Zone_Norm | | | | | | | | | | | | | | | | | +----------+ | | | | | | | | | | page page |Zone_DMA | | | | | +-+--+--+--+--+ | | | | | | | | | | | | 如上图，内核将内存划分为从大到小的三类管理单元，分别是： 节点（Node） 现代计算机系统，特别是服务器中可能会存在多个物理内存节点。节点也因此成为了Linux内核的最大管理单元，并使用数据结构pglist_data来定义它。 区域（Zone） 根据内核运行时的整个系统的工作方式，内核将线性（虚拟）地址空间划分为了不同的区域，用作不同的用途。下表列出了当前内核支持的所有区域类型及一些说明： 区域类型 说明 ZONE_DMA, ZONE_DMA32 DMA区，主要分给系统中的DMA使用。该区域往往存在于第一个内存节点的低地址位置。这是因为某些DMA硬件并不具备访问高地址范围的能力。 ZONE_NORMAL 普通内存分配区。内核中大部分内存分配取自该区域。 ZONE_HIGHMEM 高端内存，仅存在于32位系统中。在32位系统中，最大寻址空间为4GB，按照1：3的比例划分，896MB以上的物理地址均为高端内存。高端内存主要用作内核固定映射、用户空间态程序及内核态Vmalloc的内存分配。64位系统寻址空间足够大，无需按照1:3的比例来划分非高端内存和高端内存，仅将内存划分为DMA区域、普通内存区和可移动内存分配区。 ZONE_MOVEABLE 可移动内存区。现代应用频繁内存分配释放造成内存碎片化，同时内存热拔插技术的产生，内核开发者增加可移动内存区域。通过对页表指向的调整，增加内存分配的灵活性，提高分配物理连续大内存的可能性。详见LWN.net介绍 x86_64体系结构上，可预见的未来，计算机系统所需内存远远达不到64位系统寻址空间大小（16EB）。AMD在设计之初，就决定仅使用低48位来进行寻址。同时考虑到未来的扩展性，规定第48~63位必须与第47位相同。这样整个64位线性地址空间被划分为了0 ~ 0x00007FFF'FFFFFFFF和 0xFFFF8000'00000000 ~ 0xFFFFFFFF' FFFFFFFF两个部分。 现代系统往往选择将线性地址0 ~ 0x00007FFF'FFFFFFFF作为应用程序使用，而将0xFFFF8000'00000000 ~ 0xFFFFFFFF'FFFFFFFF分给内核使用。这种分法称为Canonical form addresses。其好处是将来寻址范围变大时，系统无需过多改动便可兼容。 页（Page） 页是CPU进行内存寻址的基本单元，Linux操作系统的分配器也是围绕着该单元进行内存分配及释放管理。即： 伙伴系统按页对内存进行分配。 而SLAB将页划分为更小的单位，满足对内核更小内存使用的需求。 虚拟地址管理 如下图，在Intel x64架构上，可以配置成支持4级页表48位内存寻址，最终页大小为4KB（也可配置成5级页表寻址或2MB大小的页，详见Intel® 64 and IA-32 Architectures Software Developer’s Manual>）。 Linux内核通过为不同进程建立不同的页表，来保证每个进程都有自己独立可寻址的64位地址空间。如前一章节，目前Linux虚拟地址空间采用Canonical form addresses。在选择4级页表寻址的情况下，虚拟地址空间实际划分如下图（图中字段的含义会在后续章节穿插介绍）。 参考 Linux源码. https://kernel.org/. Linux官方文档. https://docs.kernel.org/. Intel® 64 and IA-32 Architectures Software Developer’s Manual. https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html. Linux Memory Management. https://www.kernel.org/doc/html/latest/x86/x86_64/mm.html?highlight=virtual%20memory Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"3-Memory Management/2-Initialization.html":{"url":"3-Memory Management/2-Initialization.html","title":"Initialization","keywords":"","body":"内核的初始化过程，按照先后顺序会经历以下几个阶段： Loader跳转到内核后的实模式(Real Mode) 32位保护模式跳转到64位长模式 内核解压 页表映射建立，执行平台相关初始化代码 执行平台无关初始化代码 本章节介绍以下部分： 内核虚拟地址空间的建立 内核地址空间随机化(KASLR)及内核解压 平台初始化过程中的内存初始化 286: 0000000000d35000 0 NOTYPE GLOBAL HIDDEN 6 _bss 275: 0000000000d57880 0 NOTYPE GLOBAL HIDDEN 6 _ebss 277: 0000000000000000 0 NOTYPE GLOBAL HIDDEN 1 _head 330: 0000000000d6a000 0 NOTYPE GLOBAL HIDDEN 7 _end 218: 0000000000d49010 8 OBJECT GLOBAL HIDDEN 6 boot_params 101: 0000000000d34bb0 20 OBJECT LOCAL DEFAULT 5 cmdline 解压前，startup_32 (0x100000)建立4GB Boot页表 (pgtable in .pgtable)，跳转到startup_64(0x100200) startup_64 boot_stack_end = 0x4bb6000 (移动到LOAD_PHYSICAL_ADDR后的栈地址) trampoline 0x9d000 Copy compressed kernel %rsi = 0xe34ff8 %rdi = 0x4ba1ff8 (移动到LOAD_PHYSICAL_ADDR后的_bss地址) 计算.Lrelocated地址 (移动到LOAD_PHYSICAL_ADDR后的地址) 0x4b8f060 跳掉.Lrelocated地址执行，加载第二阶段IDT，boot_page_fault->do_boot_page_fault 主要作用是add_identity_map 到top_level_pgt 创建 identity maps [_head, _end] [boot_params] [cmdline] 更新CR3位top_level_pgt B在0x0000000004b8f0b6 是解压内核后的返回处 更换新页表在0x100007d Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"3-Memory Management/3-Memblock To Buddy.html":{"url":"3-Memory Management/3-Memblock To Buddy.html","title":"Memblock To Buddy","keywords":"","body":"Page Table TLB Cache 原则 Memblock Buddy Allocator Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"3-Memory Management/4-Slab and Memory Validation.html":{"url":"3-Memory Management/4-Slab and Memory Validation.html","title":"Slab And Memory Validation","keywords":"","body":"Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"3-Memory Management/5-Process Memmap and Rmap.html":{"url":"3-Memory Management/5-Process Memmap and Rmap.html","title":"Process Memmap And Rmap","keywords":"","body":"Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"3-Memory Management/6-Swap Reclaimation and OOM.html":{"url":"3-Memory Management/6-Swap Reclaimation and OOM.html","title":"Swap Reclaimation And OOM","keywords":"","body":"Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"3-Memory Management/Memory Debug.html":{"url":"3-Memory Management/Memory Debug.html","title":"Memory Debug","keywords":"","body":"Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"5-Device Driver Model/1-PCI.html":{"url":"5-Device Driver Model/1-PCI.html","title":"PCI","keywords":"","body":"Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"5-Device Driver Model/2-SDIO.html":{"url":"5-Device Driver Model/2-SDIO.html","title":"SDIO","keywords":"","body":"Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"5-Device Driver Model/3-USB.html":{"url":"5-Device Driver Model/3-USB.html","title":"USB","keywords":"","body":"Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "},"5-Device Driver Model/4-I2C.html":{"url":"5-Device Driver Model/4-I2C.html","title":"I2C","keywords":"","body":"Copyright @ Lambert 2022 all right reserved，powered by GitbookModified Time： 2024-02-24 14:20:10 "}}